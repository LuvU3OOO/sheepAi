var i = Object.defineProperty;
var p = (o, s, t) => s in o ? i(o, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[s] = t;
var r = (o, s, t) => (p(o, typeof s != "symbol" ? s + "" : s, t), t);
class h {
  constructor() {
    // 事件池
    r(this, "pools", {});
  }
  // 移除事件监听
  remove(s, t, n) {
    const a = this.pools[s] && this.pools[s][t];
    a && (this.pools[s][t] = a.filter((e) => e !== n));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(s) {
    this.pools[s] = {};
  }
  // 注册事件监听
  on(s, t) {
    return this.pools[s] || (this.pools[s] = {}), this.pools[s][t.name] || (this.pools[s][t.name] = []), this.pools[s][t.name].push(t.callback), this.pools[s][t.name].includes(t.callback);
  }
  // 触发事件
  emit(s, t, ...n) {
    this.pools[s] || (this.pools[s] = {});
    const a = this.pools[s][t];
    a && a.forEach((e) => {
      try {
        e(...n);
      } catch (c) {
        console.error(`${t} monitor event exception！`, c);
      }
    });
  }
}
const C = new h(), u = "onSave", g = "changeCatalogVisible", R = "changeFullscreen", A = "pageFullscreenChanged", _ = "fullscreenChanged", L = "previewChanged", d = "htmlPreviewChanged", N = "catalogVisibleChanged", f = "buildFinished", G = "errorCatcher", H = "replace", b = "uploadImage", m = "openModals", I = "ctrlZ", S = "ctrlShiftZ", D = "catalogChanged", F = "pushCatalog", T = "rerender", O = (o, s = "image.png") => {
  const t = o.split(","), n = t[0].match(/:(.*?);/);
  if (n) {
    const l = n[1], a = atob(t[1]);
    let e = a.length;
    const c = new Uint8Array(e);
    for (; e--; )
      c[e] = a.charCodeAt(e);
    return new File([c], s, { type: l });
  }
  return null;
}, w = (o) => {
  if (!o)
    return o;
  const s = o.split(`
`), t = ['<span rn-wrapper aria-hidden="true">'];
  return s.forEach(() => {
    t.push("<span></span>");
  }), t.push("</span>"), `<span class="code-block">${o}</span>${t.join("")}`;
}, P = (o, s) => {
  if (!o || !s)
    return 0;
  const t = o == null ? void 0 : o.getBoundingClientRect();
  if (s === document.documentElement)
    return t.top - s.clientTop;
  const n = s == null ? void 0 : s.getBoundingClientRect();
  return t.top - n.top;
};
export {
  f as B,
  D as C,
  G as E,
  _ as F,
  d as H,
  u as O,
  F as P,
  T as R,
  b as U,
  w as a,
  C as b,
  g as c,
  A as d,
  L as e,
  N as f,
  P as g,
  H as h,
  R as i,
  O as j,
  m as k,
  S as l,
  I as m
};
