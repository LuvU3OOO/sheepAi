{
  "version": 3,
  "sources": ["../../@lezer/yaml/dist/index.js", "../../@codemirror/lang-yaml/dist/index.js"],
  "sourcesContent": ["import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst blockEnd = 59,\n  eof = 60,\n  DirectiveEnd = 1,\n  DocEnd = 2,\n  sequenceStartMark = 3,\n  sequenceContinueMark = 4,\n  explicitMapStartMark = 5,\n  explicitMapContinueMark = 6,\n  flowMapMark = 7,\n  mapStartMark = 61,\n  mapContinueMark = 62,\n  Literal = 8,\n  QuotedLiteral = 9,\n  Anchor = 10,\n  Alias = 11,\n  Tag = 12,\n  BlockLiteralContent = 13,\n  BracketL = 19,\n  FlowSequence = 20,\n  Colon = 29,\n  BraceL = 32,\n  FlowMapping = 33;\n\nconst type_Top = 0, type_Seq = 1, type_Map = 2, type_Flow = 3;\n\nclass Context {\n  constructor(parent, depth, type) {\n    this.parent = parent;\n    this.depth = depth;\n    this.type = type;\n    this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4) + type;\n  }\n\n  static top = new Context(null, -1, type_Top)\n}\n\nfunction findColumn(input, pos) {\n  for (let col = 0, p = pos - input.pos - 1;; p--, col++) {\n    let ch = input.peek(p);\n    if (isBreakSpace(ch) || ch == -1) return col\n  }\n}\n\nfunction isNonBreakSpace(ch) {\n  return ch == 32 || ch == 9\n}\n\nfunction isBreakSpace(ch) {\n  return ch == 10 || ch == 13\n}\n\nfunction isSpace(ch) {\n  return isNonBreakSpace(ch) || isBreakSpace(ch)\n}\n\nfunction isSep(ch) {\n  return ch < 0 || isSpace(ch)\n}\n\nconst indentation = new ContextTracker({\n  start: Context.top,\n  reduce(context, term) {\n    return context.type == type_Flow && (term == FlowSequence || term == FlowMapping) ? context.parent : context\n  },\n  shift(context, term, stack, input) {\n    if (term == sequenceStartMark)\n      return new Context(context, findColumn(input, input.pos), type_Seq)\n    if (term == mapStartMark || term == explicitMapStartMark)\n      return new Context(context, findColumn(input, input.pos), type_Map)\n    if (term == blockEnd)\n      return context.parent\n    if (term == BracketL || term == BraceL)\n      return new Context(context, 0, type_Flow)\n    return context\n  },\n  hash(context) { return context.hash }\n});\n\nfunction three(input, ch, off = 0) {\n  return input.peek(off) == ch && input.peek(off + 1) == ch && input.peek(off + 2) == ch && isSep(input.peek(off + 3))\n}\n\nconst newlines = new ExternalTokenizer((input, stack) => {\n  if (input.next == -1 && stack.canShift(eof))\n    return input.acceptToken(eof)\n  let prev = input.peek(-1);\n  if ((isBreakSpace(prev) || prev < 0) && stack.context.type != type_Flow) {\n    if (three(input, 45 /* '-' */)) {\n      if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);\n      else return input.acceptToken(DirectiveEnd, 3)\n    }\n    if (three(input, 46 /* '.' */)) {\n      if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);\n      else return input.acceptToken(DocEnd, 3)\n    }\n    let depth = 0;\n    while (input.next == 32 /* ' ' */) { depth++; input.advance(); }\n    if ((depth < stack.context.depth ||\n         depth == stack.context.depth && stack.context.type == type_Seq &&\n         (input.next != 45 /* '-' */ || !isSep(input.peek(1)))) &&\n        // Not blank\n        input.next != -1 && input.next != 10 && input.next != 13 && input.next != 35 /* '#' */)\n      input.acceptToken(blockEnd, -depth);\n  }\n}, {contextual: true});\n\nconst blockMark = new ExternalTokenizer((input, stack) => {\n  if (stack.context.type == type_Flow) {\n    if (input.next == 63 /* '?' */) {\n      input.advance();\n      if (isSep(input.next)) input.acceptToken(flowMapMark);\n    }\n    return\n  }\n  if (input.next == 45 /* '-' */) {\n    input.advance();\n    if (isSep(input.next))\n      input.acceptToken(stack.context.type == type_Seq && stack.context.depth == findColumn(input, input.pos - 1)\n                        ? sequenceContinueMark : sequenceStartMark);\n  } else if (input.next == 63 /* '?' */) {\n    input.advance();\n    if (isSep(input.next))\n      input.acceptToken(stack.context.type == type_Map && stack.context.depth == findColumn(input, input.pos - 1)\n                        ? explicitMapContinueMark : explicitMapStartMark);\n  } else {\n    let start = input.pos;\n    // Scan over a potential key to see if it is followed by a colon.\n    for (;;) {\n      if (isNonBreakSpace(input.next)) {\n        if (input.pos == start) return\n        input.advance();\n      } else if (input.next == 33 /* '!' */) {\n        readTag(input);\n      } else if (input.next == 38 /* '&' */) {\n        readAnchor(input);\n      } else if (input.next == 42 /* '*' */) {\n        readAnchor(input);\n        break\n      } else if (input.next == 39 /* \"'\" */ || input.next == 34 /* '\"' */) {\n        if (readQuoted(input, true)) break\n        return\n      } else if (input.next == 91 /* '[' */ || input.next == 123 /* '{' */) {\n        if (!scanBrackets(input)) return\n        break\n      } else {\n        readPlain(input, true, false, 0);\n        break\n      }\n    }\n    while (isNonBreakSpace(input.next)) input.advance();\n    if (input.next == 58 /* ':' */) {\n      if (input.pos == start && stack.canShift(Colon)) return\n      let after = input.peek(1);\n      if (isSep(after))\n        input.acceptTokenTo(stack.context.type == type_Map && stack.context.depth == findColumn(input, start)\n                            ? mapContinueMark : mapStartMark, start);\n    }\n  }\n}, {contextual: true});\n\nfunction uriChar(ch) {\n  return ch > 32 && ch < 127 && ch != 34 && ch != 37 && ch != 44 && ch != 60 &&\n    ch != 62 && ch != 92 && ch != 94 && ch != 96 && ch != 123 && ch != 124 && ch != 125\n}\n\nfunction hexChar(ch) {\n  return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70\n}\n\nfunction readUriChar(input, quoted) {\n  if (input.next == 37 /* '%' */) {\n    input.advance();\n    if (hexChar(input.next)) input.advance();\n    if (hexChar(input.next)) input.advance();\n    return true\n  } else if (uriChar(input.next) || quoted && input.next == 44 /* ',' */) {\n    input.advance();\n    return true\n  }\n  return false\n}\n\nfunction readTag(input) {\n  input.advance(); // !\n  if (input.next == 60 /* '<' */) {\n    input.advance();\n    for (;;) {\n      if (!readUriChar(input, true)) {\n        if (input.next == 62 /* '>' */) input.advance();\n        break\n      }\n    }\n  } else {\n    while (readUriChar(input, false)) {}\n  }\n}\n\nfunction readAnchor(input) {\n  input.advance();\n  while (!isSep(input.next) && charTag(input.tag) != \"f\") input.advance();\n}\n  \nfunction readQuoted(input, scan) {\n  let quote = input.next, lineBreak = false, start = input.pos;\n  input.advance();\n  for (;;) {\n    let ch = input.next;\n    if (ch < 0) break\n    input.advance();\n    if (ch == quote) {\n      if (ch == 39 /* \"'\" */) {\n        if (input.next == 39) input.advance();\n        else break\n      } else {\n        break\n      }\n    } else if (ch == 92 /* \"\\\\\" */ && quote == 34 /* '\"' */) {\n      if (input.next >= 0) input.advance();\n    } else if (isBreakSpace(ch)) {\n      if (scan) return false\n      lineBreak = true;\n    } else if (scan && input.pos >= start + 1024) {\n      return false\n    }\n  }\n  return !lineBreak\n}\n\nfunction scanBrackets(input) {\n  for (let stack = [], end = input.pos + 1024;;) {\n    if (input.next == 91 /* '[' */ || input.next == 123 /* '{' */) {\n      stack.push(input.next);\n      input.advance();\n    } else if (input.next == 39 /* \"'\" */ || input.next == 34 /* '\"' */) {\n      if (!readQuoted(input, true)) return false\n    } else if (input.next == 93 /* ']' */ || input.next == 125 /* '}' */) {\n      if (stack[stack.length - 1] != input.next - 2) return false\n      stack.pop();\n      input.advance();\n      if (!stack.length) return true\n    } else if (input.next < 0 || input.pos > end || isBreakSpace(input.next)) {\n      return false\n    } else {\n      input.advance();\n    }\n  }\n}\n\n// \"Safe char\" info for char codes 33 to 125. s: safe, i: indicator, f: flow indicator\nconst charTable = \"iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif\";\n\nfunction charTag(ch) {\n  if (ch < 33) return \"u\"\n  if (ch > 125) return \"s\"\n  return charTable[ch - 33]\n}\n\nfunction isSafe(ch, inFlow) {\n  let tag = charTag(ch);\n  return tag != \"u\" && !(inFlow && tag == \"f\")\n}\n\nfunction readPlain(input, scan, inFlow, indent) {\n  if (charTag(input.next) == \"s\" ||\n      (input.next == 63 /* '?' */ || input.next == 58 /* ':' */ || input.next == 45 /* '-' */) &&\n      isSafe(input.peek(1), inFlow)) {\n    input.advance();\n  } else {\n    return false\n  }\n  let start = input.pos;\n  for (;;) {\n    let next = input.next, off = 0, lineIndent = indent + 1;\n    while (isSpace(next)) {\n      if (isBreakSpace(next)) {\n        if (scan) return false\n        lineIndent = 0;\n      } else {\n        lineIndent++;\n      }\n      next = input.peek(++off);\n    }\n    let safe = next >= 0 &&\n        (next == 58 /* ':' */ ? isSafe(input.peek(off + 1), inFlow) :\n         next == 35 /* '#' */ ? input.peek(off - 1) != 32 /* ' ' */ :\n         isSafe(next, inFlow));\n    if (!safe || !inFlow && lineIndent <= indent ||\n        lineIndent == 0 && !inFlow && (three(input, 45, off) || three(input, 46, off)))\n      break\n    if (scan && charTag(next) == \"f\") return false\n    for (let i = off; i >= 0; i--) input.advance();\n    if (scan && input.pos > start + 1024) return false\n  }\n  return true\n}\n\nconst literals = new ExternalTokenizer((input, stack) => {\n  if (input.next == 33 /* '!' */) {\n    readTag(input);\n    input.acceptToken(Tag);\n  } else if (input.next == 38 /* '&' */ || input.next == 42 /* '*' */) {\n    let token = input.next == 38 ? Anchor : Alias;\n    readAnchor(input);\n    input.acceptToken(token);\n  } else if (input.next == 39 /* \"'\" */ || input.next == 34 /* '\"' */) {\n    readQuoted(input, false);\n    input.acceptToken(QuotedLiteral);\n  } else if (readPlain(input, false, stack.context.type == type_Flow, stack.context.depth)) {\n    input.acceptToken(Literal);\n  }\n});\n\nconst blockLiteral = new ExternalTokenizer((input, stack) => {\n  let indent = -1, upto = input.pos;\n  scan: for (;;) {\n    let depth = 0, next = input.next;\n    while (next == 32 /* ' ' */) next = input.peek(++depth);\n    if (!depth && (three(input, 45, depth) || three(input, 46, depth))) break\n    if (!isBreakSpace(next)) {\n      if (indent < 0) indent = Math.max(stack.context.depth + 1, depth);\n      if (depth < indent) break\n    }\n    for (;;) {\n      if (input.next < 0) break scan\n      let isBreak = isBreakSpace(input.next);\n      input.advance();\n      if (isBreak) continue scan\n      upto = input.pos;\n    }\n  }\n  input.acceptTokenTo(BlockLiteralContent, upto);\n});\n\nconst yamlHighlighting = styleTags({\n  DirectiveName: tags.keyword,\n  DirectiveContent: tags.attributeValue,\n  \"DirectiveEnd DocEnd\": tags.meta,\n  QuotedLiteral: tags.string,\n  BlockLiteralHeader: tags.special(tags.string),\n  BlockLiteralContent: tags.content,\n  Literal: tags.content,\n  \"Key/Literal Key/QuotedLiteral\": tags.definition(tags.propertyName),\n  \"Anchor Alias\": tags.labelName,\n  Tag: tags.typeName,\n  Comment: tags.lineComment,\n  \": , -\": tags.separator,\n  \"?\": tags.punctuation,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"4WQ!ZQgOOO#PQfO'#CpO#uQfO'#C}OOQR'#Dr'#DrO$qQgO'#DQO%OQcO'#DPO%rQdO'#DTO%yQgO'#DTO&^QcO'#DSO&lOaO'#DWOOQR'#Dq'#DqO'fQgO'#DYO(]QgO'#D[OOQR'#Dp'#DpO)SOqO'#D^OOQP'#Df'#DfO)eQaO'#CmO)sQgO'#CmOOQP'#Cm'#CmQ*TQaOOQ*`QgOOQ]QgOOO*jQdO'#CrO+XQdO'#CtOOQO'#Ds'#DsO+vQ`O'#CxO,RQdO'#CwO,]Q`O'#CwO,bQdO'#CwOOQO'#Cv'#CvOOQO'#Cq'#CqO,oQ`O,59[O,wQfO,59[OOQR,59[,59[OOQO'#Cx'#CxO-OQ`O'#DOO-ZQdO'#DOO-eQdO'#DOO-rQ`O,59iO-zQfO,59iOOQR,59i,59iOOQR,59l,59lO.RQgO'#DROOQR'#Dd'#DdO.`QcO,59kOOQR,59k,59kO.kQgO,59oO.{Q`O,59oOOQR'#DU'#DUO#|QfO,59oO/QQcO,59oO/cQdO'#DVO/jQgO'#DVOOQR'#De'#DeO/}QcO,59nOOQR,59n,59nOOQR,59r,59rO0]OWO,59rO0bOaO,59rO0jOaO,59rO0uQgO'#DZOOQR,59t,59tO1iQgO'#D]OOQR,59v,59vOOQP,59x,59xO2]OaO,59xO2eOaO,59xO2sOqO,59xOOQP-E7d-E7dO3RQgO,59XOOQP,59X,59XO3cQaO'#DaO3qQgO'#DaO4RQgO'#DgOOQP'#Dg'#DgQ*TQaOOO4cQdO'#CsOOQO,59^,59^O4}QdO'#CuOOQO,59`,59`OOQO,59c,59cO5iQdO,59cO5sQ`O,59cOOQU,59|,59|OOQR1G.v1G.vO5xQ`O1G.vOOQU-E7`-E7`O6QQdO,59jOOQO,59j,59jO6[Q`O,59jOOQU,59},59}OOQR1G/T1G/TO6aQ`O1G/TOOQU-E7a-E7aOOQR,59m,59mOOQR-E7b-E7bOOQR1G/V1G/VOOQR1G/Z1G/ZO6iQgO1G/ZO#|QfO1G/ZO6yQgO,59qO7ZQ`O,59qO#|QfO,59qO7`QcO,59qOOQR-E7c-E7cOOQR1G/Y1G/YOOQR1G/^1G/^O7qOWO1G/^O7vOaO1G/^OOQR,59u,59uOOQR,59w,59wOOQP1G/d1G/dO8OOaO1G/dO8WOaO1G/dO8cOaO1G/dOOQP1G.s1G.sO8qQgO,59{OOQP,59{,59{OOQP,5:R,5:ROOQP-E7e-E7eOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}O9RQdO1G.}OOQR7+$b7+$bP,rQ`O'#DbOOQO1G/U1G/UO9]QdO1G/UOOQR7+$o7+$oP9gQ`O'#DcOOQR7+$u7+$uOOQR1G/]1G/]O9lQgO1G/]O#|QfO1G/]OOQR7+$x7+$xO9|OWO7+$xOOQP7+%O7+%OO:ROaO7+%OO:ZOaO7+%OOOQP1G/g1G/gOOQO7+$i7+$iOOQO7+$p7+$pOOQR7+$w7+$wOOQR<<Hd<<HdOOQP<<Hj<<HjO:fOaO<<HjOOQPAN>UAN>U\",\n  stateData: \":n~O!bOS!cOS^OS~OPaOQdORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!R^O!_UO~O`eO~P]OVlOWROXROYgOZhO[fOcPOmjOpQO~ObqO~P!bOVuOWROXROYgOZhO[fOcPOmtOpQO~OoxO~P#WORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!_UO~OStX!]tX!^tX~P#|OSzO!]}O!^}O~OWROXROYgOZhO[fOcPOpQO~Om!OO~P%ZOm!ROUwX!]wX!^wX!`wX~P#|OU!UO!]!XO!^!XO!`!TO~O^![O!^!YO!b!]O!c!ZO~ORSOTVOWROXROcPOpQO{XO!_UO~OY!^OP|XQ|X!R|X![|XS|X!]|X!^|XU|Xm|X!`|X~P&zO[!`OP!OXQ!OX!R!OX![!OXS!OX!]!OX!^!OXU!OXm!OX!`!OX~P&zO^!cO!S!dO!^!bO!b!eO!c!bO~OP!gO!R^OQaX![aX~OPaXQaX!RaX![aX~P#|OP!jOQ!kO!R^O~OPaO!R^O~P#|OWROXROY!nOcPOpQObfXmfXnfXofX~OWROXRO[!pOcPOpQObhXmhXnhXohX~ObeXmlXneX~ObkXnkX~P%ZOm!sO~Om!sObkXnkX~P%ZOb!vOn!uO~Ob!vO~P!bOm!yOnrXorX~OnrXorX~P%ZOm!yOnrXorX~P%ZOn!|Oo!}O~Oo!}O~P#WOSuX!]uX!^uX~P#|OSzO!]#SO!^#SO~OUwa!]wa!^wa!`wa~P#|Om#UO~Om#VOUwa!]wa!^wa!`wa~Om#WO~P%ZOm#YOUyX!]yX!^yX!`yX~P#|OU!UO!]#]O!^#]O!`!TO~O]#^O~O!^#^O!c#_O~O^#`O!^#^O!c#_O~OP}XQ}X!R}X![}XS}X!]}X!^}XU}Xm}X!`}X~P&zOP!PXQ!PX!R!PX![!PXS!PX!]!PX!^!PXU!PXm!PX!`!PX~P&zO!^#cO!c#cO~O^#dO!^#cO!b#eO!c#cO~O^#dO!S#fO!^#cO!c#cO~OPaaQaa!Raa![aa~P#|OP#hO!R^OQ!TX![!TX~OP!TXQ!TX!R!TX![!TX~P#|OPaO!R^OQ!ZX![!ZX~P#|OWROXROcPOpQObgXmgXngXogX~OWROXROcPOpQObiXmiXniXoiX~Obkanka~P%ZOm#oO~Ob#pOn!uO~Onraora~P%ZOm#sO~On!|Oo#tO~OUwi!]wi!^wi!`wi~P#|OUya!]ya!^ya!`ya~P#|Om#xO~Om#yOUya!]ya!^ya!`ya~O]#zO~O!^#zO!c#{O~O!^#|O!c#|O~O^#}O!^#|O!c#|O~O^#}O!^#|O!b$OO!c#|O~OP!TaQ!Ta!R!Ta![!Ta~P#|Obkinki~P%ZOnriori~P%ZOn!|O~OUyi!]yi!^yi!`yi~P#|O]$TO~O!^$UO!c$UO~O^$VO!^$UO!c$UO~O!^$WO!c$WO~O\",\n  goto: \",d!hPPPPPPPPPPPPPPPPP!iPP!q#o#u$V#u$Y$]$a$ePPPP!q$|%S%n&Y%S&^&x'O%SP'S'j'S'm'pPP'z(O(U([(b(h(vPPPPPPPP(|)z*n+vUcOdeR#j!k!wROPQSUVZ[adefgjlptuwz!O!R!T!U!^!`!g!j!k!n!p!s!y#U#V#W#Y#h#o#s#x#yQoPR!wpmhPQUjlptuw!T!s!y#o#sR!ofR!qgTnPpTmPpSkPpSsQwQ!PUQ!tlQ!ztQ!{uR#X!TQvQR#Ow!RYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#y!RTOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yT{T|!RWOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yQ!SVR#Z!UT!VW!Wy]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yR!_ZR!a[a_O`cde!i!k!mT!lc!mQpPR!xpQwQR#PwQ|TR#R|Q!WWR#[!WW`Ode!kS!f`!iT!ic!mQ!mcR#k!mWbOde!kQySS!QV!UQ!haQ#QzS#T!O!RQ#g!gQ#i!jS#v#U#VS#w#W#YQ$P#hT$S#x#yx]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yQ!_ZQ!a[Q#a!^R#b!`!QYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#ylhPQUjlptuw!T!s!y#o#sQ!ofQ!qgQ#l!nR#m!pSiPp^rQUltuw!TQ!rjQ#n!sQ#r!yQ$Q#oR$R#s\",\n  nodeNames: \"âš  DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : , } { FlowMapping Pair BlockSequence Item Item BlockMapping Pair Key Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document\",\n  maxTerm: 69,\n  context: indentation,\n  nodeProps: [\n    [\"isolate\", -3,8,9,14,\"\"],\n    [\"openedBy\", 18,\"[\",31,\"{\"],\n    [\"closedBy\", 19,\"]\",32,\"}\"]\n  ],\n  propSources: [yamlHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 6,\n  tokenData: \"-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!b~XY$Qpq$Q~$bO!c~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!SQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!SQ!RPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUnP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[{P!SQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW{P!SQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U{P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY{P!SQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUpP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UoP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P\",\n  tokenizers: [newlines, blockMark, literals, blockLiteral, 0, 1],\n  topRules: {\"Stream\":[0,15]},\n  tokenPrec: 0\n});\n\nexport { parser };\n", "import { parser } from '@lezer/yaml';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\n/**\nA language provider based on the [Lezer YAML\nparser](https://github.com/lezer-parser/yaml), extended with\nhighlighting and indentation information.\n*/\nconst yamlLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"yaml\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Stream: cx => {\n                    for (let before = cx.node.resolve(cx.pos, -1); before && before.to >= cx.pos; before = before.parent) {\n                        if (before.name == \"BlockLiteralContent\" && before.from < before.to)\n                            return cx.baseIndentFor(before);\n                        if (before.name == \"BlockLiteral\")\n                            return cx.baseIndentFor(before) + cx.unit;\n                        if (before.name == \"BlockSequence\" || before.name == \"BlockMapping\")\n                            return cx.column(before.from, 1);\n                        if (before.name == \"QuotedLiteral\")\n                            return null;\n                        if (before.name == \"Literal\") {\n                            let col = cx.column(before.from, 1);\n                            if (col == cx.lineIndent(before.from, 1))\n                                return col; // Start on own line\n                            if (before.to > cx.pos)\n                                return null;\n                        }\n                    }\n                    return null;\n                },\n                FlowMapping: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                FlowSequence: /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"FlowMapping FlowSequence\": foldInside,\n                \"BlockSequence BlockMapping BlockLiteral\": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*[\\]\\}]$/,\n    }\n});\n/**\nLanguage support for YAML.\n*/\nfunction yaml() {\n    return new LanguageSupport(yamlLanguage);\n}\n\nexport { yaml, yamlLanguage };\n"],
  "mappings": "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",
  "names": []
}
