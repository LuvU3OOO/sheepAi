import {
  ContextTracker,
  ExternalTokenizer,
  LRLanguage,
  LRParser,
  LanguageSupport,
  delimitedIndent,
  foldInside,
  foldNodeProp,
  indentNodeProp,
  styleTags,
  tags
} from "./chunk-L54UCQSN.js";
import {
  __publicField
} from "./chunk-7REXU52E.js";

// node_modules/@lezer/yaml/dist/index.js
var blockEnd = 59;
var eof = 60;
var DirectiveEnd = 1;
var DocEnd = 2;
var sequenceStartMark = 3;
var sequenceContinueMark = 4;
var explicitMapStartMark = 5;
var explicitMapContinueMark = 6;
var flowMapMark = 7;
var mapStartMark = 61;
var mapContinueMark = 62;
var Literal = 8;
var QuotedLiteral = 9;
var Anchor = 10;
var Alias = 11;
var Tag = 12;
var BlockLiteralContent = 13;
var BracketL = 19;
var FlowSequence = 20;
var Colon = 29;
var BraceL = 32;
var FlowMapping = 33;
var type_Top = 0;
var type_Seq = 1;
var type_Map = 2;
var type_Flow = 3;
var _Context = class _Context {
  constructor(parent, depth, type) {
    this.parent = parent;
    this.depth = depth;
    this.type = type;
    this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4) + type;
  }
};
__publicField(_Context, "top", new _Context(null, -1, type_Top));
var Context = _Context;
function findColumn(input, pos) {
  for (let col = 0, p = pos - input.pos - 1; ; p--, col++) {
    let ch = input.peek(p);
    if (isBreakSpace(ch) || ch == -1)
      return col;
  }
}
function isNonBreakSpace(ch) {
  return ch == 32 || ch == 9;
}
function isBreakSpace(ch) {
  return ch == 10 || ch == 13;
}
function isSpace(ch) {
  return isNonBreakSpace(ch) || isBreakSpace(ch);
}
function isSep(ch) {
  return ch < 0 || isSpace(ch);
}
var indentation = new ContextTracker({
  start: Context.top,
  reduce(context, term) {
    return context.type == type_Flow && (term == FlowSequence || term == FlowMapping) ? context.parent : context;
  },
  shift(context, term, stack, input) {
    if (term == sequenceStartMark)
      return new Context(context, findColumn(input, input.pos), type_Seq);
    if (term == mapStartMark || term == explicitMapStartMark)
      return new Context(context, findColumn(input, input.pos), type_Map);
    if (term == blockEnd)
      return context.parent;
    if (term == BracketL || term == BraceL)
      return new Context(context, 0, type_Flow);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
function three(input, ch, off = 0) {
  return input.peek(off) == ch && input.peek(off + 1) == ch && input.peek(off + 2) == ch && isSep(input.peek(off + 3));
}
var newlines = new ExternalTokenizer((input, stack) => {
  if (input.next == -1 && stack.canShift(eof))
    return input.acceptToken(eof);
  let prev = input.peek(-1);
  if ((isBreakSpace(prev) || prev < 0) && stack.context.type != type_Flow) {
    if (three(
      input,
      45
      /* '-' */
    )) {
      if (stack.canShift(blockEnd))
        input.acceptToken(blockEnd);
      else
        return input.acceptToken(DirectiveEnd, 3);
    }
    if (three(
      input,
      46
      /* '.' */
    )) {
      if (stack.canShift(blockEnd))
        input.acceptToken(blockEnd);
      else
        return input.acceptToken(DocEnd, 3);
    }
    let depth = 0;
    while (input.next == 32) {
      depth++;
      input.advance();
    }
    if ((depth < stack.context.depth || depth == stack.context.depth && stack.context.type == type_Seq && (input.next != 45 || !isSep(input.peek(1)))) && // Not blank
    input.next != -1 && input.next != 10 && input.next != 13 && input.next != 35)
      input.acceptToken(blockEnd, -depth);
  }
}, { contextual: true });
var blockMark = new ExternalTokenizer((input, stack) => {
  if (stack.context.type == type_Flow) {
    if (input.next == 63) {
      input.advance();
      if (isSep(input.next))
        input.acceptToken(flowMapMark);
    }
    return;
  }
  if (input.next == 45) {
    input.advance();
    if (isSep(input.next))
      input.acceptToken(stack.context.type == type_Seq && stack.context.depth == findColumn(input, input.pos - 1) ? sequenceContinueMark : sequenceStartMark);
  } else if (input.next == 63) {
    input.advance();
    if (isSep(input.next))
      input.acceptToken(stack.context.type == type_Map && stack.context.depth == findColumn(input, input.pos - 1) ? explicitMapContinueMark : explicitMapStartMark);
  } else {
    let start = input.pos;
    for (; ; ) {
      if (isNonBreakSpace(input.next)) {
        if (input.pos == start)
          return;
        input.advance();
      } else if (input.next == 33) {
        readTag(input);
      } else if (input.next == 38) {
        readAnchor(input);
      } else if (input.next == 42) {
        readAnchor(input);
        break;
      } else if (input.next == 39 || input.next == 34) {
        if (readQuoted(input, true))
          break;
        return;
      } else if (input.next == 91 || input.next == 123) {
        if (!scanBrackets(input))
          return;
        break;
      } else {
        readPlain(input, true, false, 0);
        break;
      }
    }
    while (isNonBreakSpace(input.next))
      input.advance();
    if (input.next == 58) {
      if (input.pos == start && stack.canShift(Colon))
        return;
      let after = input.peek(1);
      if (isSep(after))
        input.acceptTokenTo(stack.context.type == type_Map && stack.context.depth == findColumn(input, start) ? mapContinueMark : mapStartMark, start);
    }
  }
}, { contextual: true });
function uriChar(ch) {
  return ch > 32 && ch < 127 && ch != 34 && ch != 37 && ch != 44 && ch != 60 && ch != 62 && ch != 92 && ch != 94 && ch != 96 && ch != 123 && ch != 124 && ch != 125;
}
function hexChar(ch) {
  return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
}
function readUriChar(input, quoted) {
  if (input.next == 37) {
    input.advance();
    if (hexChar(input.next))
      input.advance();
    if (hexChar(input.next))
      input.advance();
    return true;
  } else if (uriChar(input.next) || quoted && input.next == 44) {
    input.advance();
    return true;
  }
  return false;
}
function readTag(input) {
  input.advance();
  if (input.next == 60) {
    input.advance();
    for (; ; ) {
      if (!readUriChar(input, true)) {
        if (input.next == 62)
          input.advance();
        break;
      }
    }
  } else {
    while (readUriChar(input, false)) {
    }
  }
}
function readAnchor(input) {
  input.advance();
  while (!isSep(input.next) && charTag(input.tag) != "f")
    input.advance();
}
function readQuoted(input, scan) {
  let quote = input.next, lineBreak = false, start = input.pos;
  input.advance();
  for (; ; ) {
    let ch = input.next;
    if (ch < 0)
      break;
    input.advance();
    if (ch == quote) {
      if (ch == 39) {
        if (input.next == 39)
          input.advance();
        else
          break;
      } else {
        break;
      }
    } else if (ch == 92 && quote == 34) {
      if (input.next >= 0)
        input.advance();
    } else if (isBreakSpace(ch)) {
      if (scan)
        return false;
      lineBreak = true;
    } else if (scan && input.pos >= start + 1024) {
      return false;
    }
  }
  return !lineBreak;
}
function scanBrackets(input) {
  for (let stack = [], end = input.pos + 1024; ; ) {
    if (input.next == 91 || input.next == 123) {
      stack.push(input.next);
      input.advance();
    } else if (input.next == 39 || input.next == 34) {
      if (!readQuoted(input, true))
        return false;
    } else if (input.next == 93 || input.next == 125) {
      if (stack[stack.length - 1] != input.next - 2)
        return false;
      stack.pop();
      input.advance();
      if (!stack.length)
        return true;
    } else if (input.next < 0 || input.pos > end || isBreakSpace(input.next)) {
      return false;
    } else {
      input.advance();
    }
  }
}
var charTable = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function charTag(ch) {
  if (ch < 33)
    return "u";
  if (ch > 125)
    return "s";
  return charTable[ch - 33];
}
function isSafe(ch, inFlow) {
  let tag = charTag(ch);
  return tag != "u" && !(inFlow && tag == "f");
}
function readPlain(input, scan, inFlow, indent) {
  if (charTag(input.next) == "s" || (input.next == 63 || input.next == 58 || input.next == 45) && isSafe(input.peek(1), inFlow)) {
    input.advance();
  } else {
    return false;
  }
  let start = input.pos;
  for (; ; ) {
    let next = input.next, off = 0, lineIndent = indent + 1;
    while (isSpace(next)) {
      if (isBreakSpace(next)) {
        if (scan)
          return false;
        lineIndent = 0;
      } else {
        lineIndent++;
      }
      next = input.peek(++off);
    }
    let safe = next >= 0 && (next == 58 ? isSafe(input.peek(off + 1), inFlow) : next == 35 ? input.peek(off - 1) != 32 : isSafe(next, inFlow));
    if (!safe || !inFlow && lineIndent <= indent || lineIndent == 0 && !inFlow && (three(input, 45, off) || three(input, 46, off)))
      break;
    if (scan && charTag(next) == "f")
      return false;
    for (let i = off; i >= 0; i--)
      input.advance();
    if (scan && input.pos > start + 1024)
      return false;
  }
  return true;
}
var literals = new ExternalTokenizer((input, stack) => {
  if (input.next == 33) {
    readTag(input);
    input.acceptToken(Tag);
  } else if (input.next == 38 || input.next == 42) {
    let token = input.next == 38 ? Anchor : Alias;
    readAnchor(input);
    input.acceptToken(token);
  } else if (input.next == 39 || input.next == 34) {
    readQuoted(input, false);
    input.acceptToken(QuotedLiteral);
  } else if (readPlain(input, false, stack.context.type == type_Flow, stack.context.depth)) {
    input.acceptToken(Literal);
  }
});
var blockLiteral = new ExternalTokenizer((input, stack) => {
  let indent = -1, upto = input.pos;
  scan:
    for (; ; ) {
      let depth = 0, next = input.next;
      while (next == 32)
        next = input.peek(++depth);
      if (!depth && (three(input, 45, depth) || three(input, 46, depth)))
        break;
      if (!isBreakSpace(next)) {
        if (indent < 0)
          indent = Math.max(stack.context.depth + 1, depth);
        if (depth < indent)
          break;
      }
      for (; ; ) {
        if (input.next < 0)
          break scan;
        let isBreak = isBreakSpace(input.next);
        input.advance();
        if (isBreak)
          continue scan;
        upto = input.pos;
      }
    }
  input.acceptTokenTo(BlockLiteralContent, upto);
});
var yamlHighlighting = styleTags({
  DirectiveName: tags.keyword,
  DirectiveContent: tags.attributeValue,
  "DirectiveEnd DocEnd": tags.meta,
  QuotedLiteral: tags.string,
  BlockLiteralHeader: tags.special(tags.string),
  BlockLiteralContent: tags.content,
  Literal: tags.content,
  "Key/Literal Key/QuotedLiteral": tags.definition(tags.propertyName),
  "Anchor Alias": tags.labelName,
  Tag: tags.typeName,
  Comment: tags.lineComment,
  ": , -": tags.separator,
  "?": tags.punctuation,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
var parser = LRParser.deserialize({
  version: 14,
  states: "4WQ!ZQgOOO#PQfO'#CpO#uQfO'#C}OOQR'#Dr'#DrO$qQgO'#DQO%OQcO'#DPO%rQdO'#DTO%yQgO'#DTO&^QcO'#DSO&lOaO'#DWOOQR'#Dq'#DqO'fQgO'#DYO(]QgO'#D[OOQR'#Dp'#DpO)SOqO'#D^OOQP'#Df'#DfO)eQaO'#CmO)sQgO'#CmOOQP'#Cm'#CmQ*TQaOOQ*`QgOOQ]QgOOO*jQdO'#CrO+XQdO'#CtOOQO'#Ds'#DsO+vQ`O'#CxO,RQdO'#CwO,]Q`O'#CwO,bQdO'#CwOOQO'#Cv'#CvOOQO'#Cq'#CqO,oQ`O,59[O,wQfO,59[OOQR,59[,59[OOQO'#Cx'#CxO-OQ`O'#DOO-ZQdO'#DOO-eQdO'#DOO-rQ`O,59iO-zQfO,59iOOQR,59i,59iOOQR,59l,59lO.RQgO'#DROOQR'#Dd'#DdO.`QcO,59kOOQR,59k,59kO.kQgO,59oO.{Q`O,59oOOQR'#DU'#DUO#|QfO,59oO/QQcO,59oO/cQdO'#DVO/jQgO'#DVOOQR'#De'#DeO/}QcO,59nOOQR,59n,59nOOQR,59r,59rO0]OWO,59rO0bOaO,59rO0jOaO,59rO0uQgO'#DZOOQR,59t,59tO1iQgO'#D]OOQR,59v,59vOOQP,59x,59xO2]OaO,59xO2eOaO,59xO2sOqO,59xOOQP-E7d-E7dO3RQgO,59XOOQP,59X,59XO3cQaO'#DaO3qQgO'#DaO4RQgO'#DgOOQP'#Dg'#DgQ*TQaOOO4cQdO'#CsOOQO,59^,59^O4}QdO'#CuOOQO,59`,59`OOQO,59c,59cO5iQdO,59cO5sQ`O,59cOOQU,59|,59|OOQR1G.v1G.vO5xQ`O1G.vOOQU-E7`-E7`O6QQdO,59jOOQO,59j,59jO6[Q`O,59jOOQU,59},59}OOQR1G/T1G/TO6aQ`O1G/TOOQU-E7a-E7aOOQR,59m,59mOOQR-E7b-E7bOOQR1G/V1G/VOOQR1G/Z1G/ZO6iQgO1G/ZO#|QfO1G/ZO6yQgO,59qO7ZQ`O,59qO#|QfO,59qO7`QcO,59qOOQR-E7c-E7cOOQR1G/Y1G/YOOQR1G/^1G/^O7qOWO1G/^O7vOaO1G/^OOQR,59u,59uOOQR,59w,59wOOQP1G/d1G/dO8OOaO1G/dO8WOaO1G/dO8cOaO1G/dOOQP1G.s1G.sO8qQgO,59{OOQP,59{,59{OOQP,5:R,5:ROOQP-E7e-E7eOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}O9RQdO1G.}OOQR7+$b7+$bP,rQ`O'#DbOOQO1G/U1G/UO9]QdO1G/UOOQR7+$o7+$oP9gQ`O'#DcOOQR7+$u7+$uOOQR1G/]1G/]O9lQgO1G/]O#|QfO1G/]OOQR7+$x7+$xO9|OWO7+$xOOQP7+%O7+%OO:ROaO7+%OO:ZOaO7+%OOOQP1G/g1G/gOOQO7+$i7+$iOOQO7+$p7+$pOOQR7+$w7+$wOOQR<<Hd<<HdOOQP<<Hj<<HjO:fOaO<<HjOOQPAN>UAN>U",
  stateData: ":n~O!bOS!cOS^OS~OPaOQdORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!R^O!_UO~O`eO~P]OVlOWROXROYgOZhO[fOcPOmjOpQO~ObqO~P!bOVuOWROXROYgOZhO[fOcPOmtOpQO~OoxO~P#WORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!_UO~OStX!]tX!^tX~P#|OSzO!]}O!^}O~OWROXROYgOZhO[fOcPOpQO~Om!OO~P%ZOm!ROUwX!]wX!^wX!`wX~P#|OU!UO!]!XO!^!XO!`!TO~O^![O!^!YO!b!]O!c!ZO~ORSOTVOWROXROcPOpQO{XO!_UO~OY!^OP|XQ|X!R|X![|XS|X!]|X!^|XU|Xm|X!`|X~P&zO[!`OP!OXQ!OX!R!OX![!OXS!OX!]!OX!^!OXU!OXm!OX!`!OX~P&zO^!cO!S!dO!^!bO!b!eO!c!bO~OP!gO!R^OQaX![aX~OPaXQaX!RaX![aX~P#|OP!jOQ!kO!R^O~OPaO!R^O~P#|OWROXROY!nOcPOpQObfXmfXnfXofX~OWROXRO[!pOcPOpQObhXmhXnhXohX~ObeXmlXneX~ObkXnkX~P%ZOm!sO~Om!sObkXnkX~P%ZOb!vOn!uO~Ob!vO~P!bOm!yOnrXorX~OnrXorX~P%ZOm!yOnrXorX~P%ZOn!|Oo!}O~Oo!}O~P#WOSuX!]uX!^uX~P#|OSzO!]#SO!^#SO~OUwa!]wa!^wa!`wa~P#|Om#UO~Om#VOUwa!]wa!^wa!`wa~Om#WO~P%ZOm#YOUyX!]yX!^yX!`yX~P#|OU!UO!]#]O!^#]O!`!TO~O]#^O~O!^#^O!c#_O~O^#`O!^#^O!c#_O~OP}XQ}X!R}X![}XS}X!]}X!^}XU}Xm}X!`}X~P&zOP!PXQ!PX!R!PX![!PXS!PX!]!PX!^!PXU!PXm!PX!`!PX~P&zO!^#cO!c#cO~O^#dO!^#cO!b#eO!c#cO~O^#dO!S#fO!^#cO!c#cO~OPaaQaa!Raa![aa~P#|OP#hO!R^OQ!TX![!TX~OP!TXQ!TX!R!TX![!TX~P#|OPaO!R^OQ!ZX![!ZX~P#|OWROXROcPOpQObgXmgXngXogX~OWROXROcPOpQObiXmiXniXoiX~Obkanka~P%ZOm#oO~Ob#pOn!uO~Onraora~P%ZOm#sO~On!|Oo#tO~OUwi!]wi!^wi!`wi~P#|OUya!]ya!^ya!`ya~P#|Om#xO~Om#yOUya!]ya!^ya!`ya~O]#zO~O!^#zO!c#{O~O!^#|O!c#|O~O^#}O!^#|O!c#|O~O^#}O!^#|O!b$OO!c#|O~OP!TaQ!Ta!R!Ta![!Ta~P#|Obkinki~P%ZOnriori~P%ZOn!|O~OUyi!]yi!^yi!`yi~P#|O]$TO~O!^$UO!c$UO~O^$VO!^$UO!c$UO~O!^$WO!c$WO~O",
  goto: ",d!hPPPPPPPPPPPPPPPPP!iPP!q#o#u$V#u$Y$]$a$ePPPP!q$|%S%n&Y%S&^&x'O%SP'S'j'S'm'pPP'z(O(U([(b(h(vPPPPPPPP(|)z*n+vUcOdeR#j!k!wROPQSUVZ[adefgjlptuwz!O!R!T!U!^!`!g!j!k!n!p!s!y#U#V#W#Y#h#o#s#x#yQoPR!wpmhPQUjlptuw!T!s!y#o#sR!ofR!qgTnPpTmPpSkPpSsQwQ!PUQ!tlQ!ztQ!{uR#X!TQvQR#Ow!RYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#y!RTOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yT{T|!RWOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yQ!SVR#Z!UT!VW!Wy]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yR!_ZR!a[a_O`cde!i!k!mT!lc!mQpPR!xpQwQR#PwQ|TR#R|Q!WWR#[!WW`Ode!kS!f`!iT!ic!mQ!mcR#k!mWbOde!kQySS!QV!UQ!haQ#QzS#T!O!RQ#g!gQ#i!jS#v#U#VS#w#W#YQ$P#hT$S#x#yx]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yQ!_ZQ!a[Q#a!^R#b!`!QYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#ylhPQUjlptuw!T!s!y#o#sQ!ofQ!qgQ#l!nR#m!pSiPp^rQUltuw!TQ!rjQ#n!sQ#r!yQ$Q#oR$R#s",
  nodeNames: "⚠ DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : , } { FlowMapping Pair BlockSequence Item Item BlockMapping Pair Key Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 69,
  context: indentation,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 31, "{"],
    ["closedBy", 19, "]", 32, "}"]
  ],
  propSources: [yamlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!b~XY$Qpq$Q~$bO!c~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!SQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!SQ!RPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUnP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[{P!SQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW{P!SQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U{P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY{P!SQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUpP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UoP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [newlines, blockMark, literals, blockLiteral, 0, 1],
  topRules: { "Stream": [0, 15] },
  tokenPrec: 0
});

// node_modules/@codemirror/lang-yaml/dist/index.js
var yamlLanguage = LRLanguage.define({
  name: "yaml",
  parser: parser.configure({
    props: [
      indentNodeProp.add({
        Stream: (cx) => {
          for (let before = cx.node.resolve(cx.pos, -1); before && before.to >= cx.pos; before = before.parent) {
            if (before.name == "BlockLiteralContent" && before.from < before.to)
              return cx.baseIndentFor(before);
            if (before.name == "BlockLiteral")
              return cx.baseIndentFor(before) + cx.unit;
            if (before.name == "BlockSequence" || before.name == "BlockMapping")
              return cx.column(before.from, 1);
            if (before.name == "QuotedLiteral")
              return null;
            if (before.name == "Literal") {
              let col = cx.column(before.from, 1);
              if (col == cx.lineIndent(before.from, 1))
                return col;
              if (before.to > cx.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: delimitedIndent({ closing: "}" }),
        FlowSequence: delimitedIndent({ closing: "]" })
      }),
      foldNodeProp.add({
        "FlowMapping FlowSequence": foldInside,
        "BlockSequence BlockMapping BlockLiteral": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function yaml() {
  return new LanguageSupport(yamlLanguage);
}
export {
  yaml,
  yamlLanguage
};
//# sourceMappingURL=dist-JGCDI6BG.js.map
